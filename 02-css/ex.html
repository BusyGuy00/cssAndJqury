<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //객체 타입 {key : value, key2: value2 } 
        //배열타입 [1,2,3,4]
        //배열 메소드
        //1.map 배열안의 요소의 내용이 변경 (요소의 값이 변경)
        //2.filter 배열에서 새로운 배열리턴
        let numbers = [1,2,3,4,5,6];
        //map을 사용시에 원본배열 요소의 값에 1씩 더한 값을 리턴 할 수 있다 
        let number2 = numbers.map(num=> num+1);
        //[2,3,4,5,6,7]로 numbers의 +1씩 더한 값이 나온다 (값을 바꾼다)
        console.log(number2);
        //filter는 원하는 범위나 조건을 값 내에서 거를 수 있다. (값을 바꾸는게 아닌 원하는것을 받는다)
        let number3 = numbers.filter(num=> num >=5);
        //[5,6]을 받는다.
        console.log(number3);

        let users = [
            {id:1, name: "user1", score: 60},
            {id:2, name: "user2", score: 70},
            {id:3, name: "user3", score: 80},
            {id:4, name: "user4", score: 90},
            {id:5, name: "user5", score: 50},
        ]
        //users 배열의 score만 받을때는 map을 받는다 (배열 길이는 같고 특정한 값을 받아 오거나 변경 할때) 
        //map은 배열을 유지 하지만 특정한 값을 받거나(id:1, name: "user1", score: 60 이러하게 받는게 아니라)
        //[60,70,80,90,50]으로 값이 변경 되어 원하는 값을 받기 떄문에 이러한 것이 filter하고 헷갈릴 수 있다. 
        //그리고 변경 하여 받는다. = 갯수는 안바뀌고 형태만 바뀐다. 
        let scores = users.map(user=>user.score);
        //[60,70,80,90,50]

        //users 배열의 score의 기준으로 특정한 값을 받아야 할때 (배열 5개가 아닌 트정한 배열만 가져온다.)
        //형태는 안바뀌고 갯수만 바뀔 수 있다. 
        let highusers = users.filter(user=>user.score >= 70);
        //[
        //    {id:2, name: "user2", score: 70},
        //    {id:3, name: "user3", score: 80},
        //    {id:4, name: "user4", score: 90},
        //]
        let users2 = users.map(user=>{
            return {...user, score: user.score+10}
            //화살표 함수는 {}와 리턴을 생략이 가능 하다 
            //  let highusers = users.filter(user=>user.score >= 70); {}와 리턴이 생략된 화살표 함수
        });
        console.log( users2 );
        let dog = {name: "콩이", age: 3}
        dog ={
            //...dog, //name: "콩이", age: 3, 을 적어준것과 같다.(...은 스프레드 구문이라고 하며 객체를 펼쳐 준다 )
           // color : "흰색"
           ...dog,
           name: "구름" // name이라는 키 값이 같아서 이름이 구름으로 바뀐다.
        }
        console.log("dog");
        console.log(dog);
        let fruits = ["사과","딸기","포도"];
        fruits = [...fruits,"바나나"]; // 바나나가 추가 된다.
        console.log(fruits);
        let fruits2 = fruits.concat("키위"); //비슷한 기능을 하나 ...스프레드 구문을 더 사용한다.
        console.log(fruits2); 

        let obj ={
            inputs : {
                username: "green",
                email: "green@naver.com"
            },
            users: [
                {id: 1, username: "A", email: "A@naver.com"},
                {id: 2, username: "B", email: "B@naver.com"}
            ]
        }
        //obj안에  inputs 의   email:값을 바꾸는 방법
        let obj3 ={
            ...obj,
            // inputs : {
            //     username: "green",
            //     email: "blue@naver.com"
            // } //이렇게 하면  obj의 inputs 의 email값을 바꿀 수 있다. 
            //OR 
            inputs: {
                ...obj.inputs,
                email: "blue@naver.com"
            }//이렇게 간략하게도 바꿀 수 있다.

        }
        //키는 문자열 이다 , 값은 모든 데이터가 올 수 있다.(숫자,문자,객체)
        //aa: {a:1,b:2}, 객체 bb:[1,2,3]는 배열 
        let obj2 = {aa: {a:1,b:2}, bb:[1,2,{a:1,b:2}] }
        //접근 방법 
        //obj2.aa.afh obj안에 있는 aa의 a의 값인 1을 가져온다 
        //obj2.bb[2]는 obj안에 있는 bb의 값인 2를 가져온다
        //obj2.bb[2].b 는 obj안에 있는 bb의 a의 값인 1을 가져 올 수 있다. 

        //화살표 함수 
        function myFun(num){
            return num + 10;
        }
        // function의 역활을 /=>/이 대체 한다

        let myFun2 = (num) => {
            return num + 10;
        }
        //매개변수가 하나일때 () 생략 가능하다
        //실행문이 한줄일때 {} 생략이 가능 하다 
        //{}을 생략하면 return을 생략 가능 하다
        //화살표 함수의 실행문이 한줄이고 값일떄는 return문이다
        let myFun2A = num => num + 10;
        //ex>
        //let scores = users.map(user=>user.score);
        //이것또한 user=>user.score 화살표 함수이며 리턴문이다 function으로 대체 가능 하다
        let score2 = users.map(function(user){
            return user.score;
        })
        let score3 = users.map(user=>{
            return {...user, score: user.score}});
        let score4 = users.map(user=> user.score); //위와 같은 말 이다. 

        let result = myFun(5);
        console.log(result)

        let keyname = "abc";
        let name = "greengreen"
        let obj4 ={ keyname:name }
        console.log(obj4)
            //keyname을key로써 사용 하고 name을 value로 사용 하고 싶을때는 이렇게 사용 하면 된다.
        let obj4a ={ [keyname]:name }
        console.log(obj4a)
        //{abc: 'greengreen'} 이렇게 출력 된다 . 
        let color = "흰색";
        let obj5 = {color: color};
        console.log(obj5) //키 밸류 값을 출력
        let obj5A = {color}; //obj5를 obj5A로 생략
        console.log(obj5A) //키의 문자와 와 밸류의 이름이 같을 경우에 생략해서 사용 할 수 있다.
        

    </script>

</body>
</html>